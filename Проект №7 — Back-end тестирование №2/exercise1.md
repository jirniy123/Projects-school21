## Алгоритмы балансировки нагрузки

1. **Round Robin**

Round Robin, или алгоритм кругового обслуживания, представляет собой перебор по круговому циклу: первый запрос передаётся одному серверу, затем следующий запрос передаётся другому и так до достижения последнего сервера, а затем всё начинается сначала.

Самой распространёной имплементацией этого алгоритма является, конечно же, метод балансировки `Round Robin DNS`. 

*Плюсы:* 
- независимость от протокола высокого уровня: для работы по алгоритму `Round Robin` используется любой протокол, в котором обращение к серверу идёт по имени.
- не зависит от нагрузки на сервер: кэширующие DNS-серверы помогут справиться с любым наплывом клиентов.
- не требует связи между серверами, поэтому он может использоваться как для локальной, так и для глобальной балансировки.
- отличаются низкой стоимостью: чтобы они начали работать, достаточно просто добавить несколько записей в DNS.

*Недостатки:*
- наличие у каждого сервера одинакового набора ресурсов. При выполнении всех операций также должно быть задействовано одинаковое количество ресурсов. В реальной практике эти условия в большинстве случаев оказываются невыполнимыми.
- не учитывается загруженность того или иного сервера в составе кластера. Представим себе следующую гипотетическую ситуацию: один из узлов загружен на 100%, в то время как другие — всего на 10 — 15%. Алгоритм Round Robin возможности возникновения такой ситуации не учитывает в принципе, поэтому перегруженный узел все равно будет получать запросы. Ни о какой справедливости, эффективности и предсказуемости в таком случае не может быть и речи.
- не учитывается количество активных на данный момент подключений. Рассмотрим практический пример. Имеется два сервера — обозначим их условно как А и Б. К серверу А подключено меньше пользователей, чем к серверу Б. При этом сервер А оказывается более перегруженным. Как это возможно? Ответ достаточно прост: подключения к серверу А поддерживаются в течение более долгого времени по сравнению с подключениями к серверу Б.

*В силу описанных выше обстоятельств сфера применения алгоритма Round Robin весьма ограничена.*

2. **Weighted Round Robin**

Это — усовершенствованная версия алгоритма `Round Robin`. Суть усовершенствований заключается в следующем: каждому серверу присваивается весовой коэффициент в соответствии с его производительностью и мощностью. Это помогает распределять нагрузку более гибко: серверы с большим весом обрабатывают больше запросов. Это позволяет лучше справляться с колебаниями мощности серверов, чем стандартный `round robin`, но нам всё равно нужно решить вопрос колебаний запросов. 

*Недостатки*:<br>
На практике ручное указание весов быстро оказывается неэффективным. Сложно свести производительность сервера к одному числу, и для этого потребуется тщательное тестирование нагрузок с реальными рабочими нагрузками. Это делают редко.

3. **Least Connections**

Алгоритм, при котором каждый новый запрос передается на тот сервер, на котором в данный момент меньше всего активных подключений. Этот метод позволяет распределять нагрузку на серверы достаточно равномерно.

Существует усовершенствованный вариант этого алгоритма, предназначенный в первую очередь для использования в кластерах, состоящих из серверов с разными техническими характеристиками и разной производительностью. Он называется `Weighted Least Connections` и учитывает при распределении нагрузки не только количество активных подключений, но и весовой коэффициент серверов.

*Недостатки:* <br>
На первый взгляд может показаться, что планирование с наименьшим количеством подключений также может хорошо работать даже при наличии серверов различной вычислительной мощности, поскольку более быстрый сервер получит больше сетевых подключений. На самом деле, он не может работать очень хорошо из-за состояния `TIME_WAIT TCP`. Время ожидания `TCP` обычно составляет 2 минуты, в течение этих 2 минут загруженный веб-сайт часто получает тысячи подключений, например, сервер A в два раза мощнее сервера B, сервер A обрабатывает тысячи запросов и сохраняет их в состоянии `TIME_WAIT TCP`, но сервер B выполняет сканирование, чтобы завершить тысячи подключений. Таким образом, при планировании с наименьшим количеством подключений нагрузка не может быть хорошо сбалансирована между серверами с различной вычислительной мощностью.


4. **Destination Hash Scheduling и Source Hash Scheduling**

Алгоритм `Destination Hash Scheduling` был создан для работы с кластером кэширующих прокси-серверов, но он часто используется и в других случаях. В этом алгоритме сервер, обрабатывающий запрос, выбирается из статической таблицы по IP-адресу получателя.
Алгоритм `Source Hash Scheduling` основывается на тех же самых принципах, что и предыдущий, только сервер, который будет обрабатывать запрос, выбирается из таблицы по IP-адресу отправителя.

5. **Sticky Sessions**

Алгоритм распределения входящих запросов, при котором соединения передаются на один и тот же сервер группы. Сессии пользователя могут быть закреплены за конкретным сервером с помощью метода `IP hash`. С помощью этого метода запросы распределяются по серверам на основе IP-aдреса клиента. «Метод гарантирует, что запросы одного и того же клиента будет передаваться на один и тот же сервер». Если закреплённый за конкретным адресом сервер недоступен, запрос будет перенаправлен на другой сервер.

*Недостатки*: <br>
Могут возникнуть проблемы с привязкой сессий, если клиент использует динамический IP. <br> 
В ситуации, когда большое количество запросов проходит через один прокси-сервер, балансировку вряд ли можно назвать эффективной и справедливой.