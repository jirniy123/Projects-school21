## **Уровни архитектуры веб-приложений**
Существует четыре общих уровня веб-приложений:

1. Уровень представления (PL)
2. Уровень обслуживания данных (DSL)
3. Уровень бизнес-логики (BLL)
4. Уровень доступа к данным (DAL)

**Уровень представления**
PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.

**Слой бизнес-логики**
BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт - это пример уровня бизнес-логики.

**Уровень службы данных**
DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.

**Уровень доступа к данным**
DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.



## **Монолитная и микросервисная архитектуры веб-приложения**.
**Монолитная архитектура веб-приложения.**

Традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Состоит из трех частей - базы данных, клиентской и серверной сторон. Это означает, что внутренняя и внешняя логика, как и другие фоновые задачи, генерируются в одной кодовой базе. Чтобы изменить или обновить компонент приложения, разработчики программного обеспечения должны переписать все приложение. Монолитная архитектура — это отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи.

**Микросервисная архитектура веб-приложения.**

Это подход к созданию приложения, подразумевающий отказ от единой, монолитной структуры. То есть вместо того чтобы исполнять все ограниченные контексты приложения на сервере с помощью внутрипроцессных взаимодействий, мы используем несколько небольших приложений, каждое из которых соответствует какому-то ограниченному контексту. Микросервисная архитектура позволяет разработчикам создавать веб-приложение из набора небольших сервисов. Разработчики создают и развертывают каждый компонент отдельно. 

**Различия Монолитной и Микросервисной архитектуры.**

Главное отличие микросервисной архитектуры от монолитной заключается в том, что каждый процесс приложения функционирует как отдельный слабо связанный сервис со своей собственной логикой и базой данных. Обновление, развертывание, тестирование и масштабирование происходит в рамках отдельного модуля.
Несмотря на то, что микросервисы не уменьшают сложность системы, они делают ее более управляемой.

## **Почему не все приложения построены на микросервисной архитектуре?**

В зависимости от конкретного проекта и его требований применяется та или иная модель архитектуры. В некоторых случаях монолитная архитектура может быть достаточно эффективной, особенно если приложение небольшое и не нуждается в масштабировании. Микросервисы требуют больших ресурсов (времени и вычислительных мощностей) на старте.

## **Каковы особенности тестирования монолитных и микросервисных веб-приложений?**

Процесс тестирования микросервисной архитектуры значительно отличается от тестирования монолитной.
Тестирование монолитной архитектуры предполагает, что отдельные компоненты системы серьезного тестирования не проходили. Основное преимущество - отсутствие необходимости в разработке тестового окружения, драйверов и заглушек. После разработки всех модулей выполняется их интеграция, затем система проверяется вся в целом. 

Так как микросервисная архитектура — это совокупность небольших сервисов, где каждый из них обслуживает одну бизнес-задачу, и сервисы находятся на разных серверах и написаны на различных языках программирования, это делает процесс тестирования не из легких.
Тем не менее у нас есть возможность обновить отдельный микросервис быстро и протестировать его не затронув другие.

Тестирование должно происходить как на **микроуровне**, так и на **макроуровне**.

На **микроуровне** каждый сервис должен быть досконально протестирован в пределах своей зоны ответственности. Согласно некоторым трактовкам, границей микросервиса считается функция.

Целесообразно уделить особое внимание функции внутри микросервиса, учитывая нарастающую популярность бессерверной парадигмы, согласно которой микросервис нужно представлять только как единственную функцию. Но многие практикующие тестировщики при работе с микросервисами склонны ограничиваться модульными тестами. Тогда как модульный тест нормально покрывает единственную функцию, работающую в очень ограниченных тестовых условиях, микросервис рассчитан на обслуживание аудитории в рамках всего Веба. Поэтому условия тестирования должны быть экстремальными.

Тесты также должны гарантировать, что все существенные события, происходящие в микросервисе, как следует логируются – и, что не менее важно, эти записи логов можно понять.

При тестировании микросервисов на **макроуровне** необходимо убедиться, что два аспекта не вызывают нареканий: межсервисная коммуникация и процессы развертывания.

Микросервисы по определению независимы друг от друга. Они определяют, что им делать, исходя из получаемой ими информации, поэтому точность межсервисной коммуникации критически важна для целостной эксплуатации микросервисно-ориентированного приложения.

Обеспечение межсервисной коммуникации означает организацию того, чтобы правильная информация приходила откуда нужно и уходила куда нужно. Тесты должны позволять отслеживать, как происходит обмен сообщениями, и как они обрабатываются. Тестирование должно помочь убедиться, что поддерживаются форматы сообщений, обеспечивающие положительный путь работы системы, а неверно отформатированные сообщения отклоняются, причем с достаточными объяснениями (а не просто с ошибкой «плохое сообщение»).
